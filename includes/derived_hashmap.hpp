#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <cassert>
#include <cmath>
#include <string>
#include <typeinfo>
#include <type_traits>

#include "gprintf.hpp"
/**
 * Applies customized hash function to generate a hash index based on
 * characters of string argument `key`
 * @param key String value used to produce hash index
 * @return A hash index value generated by hash function using `key`
 */
extern unsigned int apply_hash_function(const std::string& key);

/**
 * Finds next prime number that is greater than or equal to `capacity_val`
 * @param capacity_val Integer value to be converted to next greater prime number
 * @return next prime number greater than `capacity_val` or `capacity_val` if it is prime
 */
extern unsigned int get_next_prime(unsigned int capacity_val);

/**
 * Evaluates whether integer value `capacity_val` is a prime number
 * @param capacity_val integer value to evaluated for being prime
 * @return `true` if `capacity_val` is found to be prime, `false` otherwise
 */
extern bool is_prime( unsigned int capacity_val);

/**
 * Customized stand-alone hashmap-like class objects that utilize open-addressing and an underlying
 * vector-type storage array `hash_bucket`  to store `hash_entry` structs that hold key : `Hash_Type` value pairs
 * @tparam Hash_Type typename of values for `soa_hashmap` class objects to store as the values of all key : `Hash_Type` value pairs
 */
template <class Hash_Type>
class soa_hashmap {
    public:
        soa_hashmap(unsigned int c): size(0), capacity(c) {fill_buckets();} // Constructor builds underlying storage array with a starting bucket capacity of `c`
        soa_hashmap(): size(0), capacity(5) {fill_buckets();} // Constructor defaults to capacity of 5 if no capacity argument is provided
        
        /**
         * Pre-fills `soa_hashmap`'s underlying vector-type storage array, `hash_bucket` with `capacity`
         * number of empty `hash_entry` structs used to hold key : value pairs
         * 
         * Upon initialization of `soa_hashmap`, all indices between 0 and `capacity` can be dynamically accessed
         */
        void fill_buckets() {
            for (unsigned int i = 0; i < capacity; i++) {
                hash_entry new_val;
                hash_bucket.insert(hash_bucket.begin() + i, new_val);
            }
        }

        /**
         * Retrieves current number of elements containing  key : value pairs stored within `hash_bucket` storage array
         * of calling `soa_hashmap` class object (Number of `hash_entry` structs)
         * @return Number of non-empty elements currently stored in calling `soa_hashmap` class object
         */
        unsigned int get_size() {
            return size;
        }

        /**
         * Retrieves total number of indices (0 to capacity - 1) that can be dynamically accessed from `hash_bucket` array
         * (Underlying array contains preallocated space for both empty and non-empty elements between this range)
         * @return Maximum number of indices currently available for value storage (indices 0 to capacity - 1)
         */
        unsigned int get_capacity() {
            return capacity;
        }

        /**
         * Retrieves current array of key values stored within `key` member of calling `soa_hashmap` class object
         * @return vector-type array holding all keys currently held within calling `soa_hashmap` class object
         */
        std::vector<std::string> get_keys() {
            return keys;
        }

        /**
         * Prints all string key values found within calling `soa_hashmap` object to std::out
         */
        void print_keys() {                  
            std::cout << "[ ";
            for (unsigned int i = 0; i < keys.size(); i++) {
                
                if ( i == keys.size() - 1) {
                    std::cout << keys[i];
                } else {
                    std::cout << keys[i] << ", ";
                }
            }
            std::cout << " ]";
        }

        /**
         * Retrieves the underlying storage array of the calling `soa_hashmap` class object
         * @return vector-type array of `hash_entry` structs holding all key : value pairs witihin
         * calling `soa_hashmap` class object
         */
        auto get_hash_bucket() {
            return hash_bucket;
        }

        /**
         * Calculates and returns the current load factor of calling `soa_hashmap` class object
         * @note Load Factor = Current number of stored key : value pairs divided by current array capacity
         * @return Value of current calculated load factor of colling `soa_hashmap` class object
         */
        double table_load() {
            double load_factor = static_cast<double>(size) / static_cast<double>(capacity);
            return load_factor;
        }

        /**
         * Modifies the capacity of calling `soa_hashmap` object's underlying storage array `hash_bucket` to
         * either the value of `new_capacity`, if it is a prime value, or the next prime value greater
         * than `new_capacity`
         * @param new_capacity Value to be used in readjusting the capacity of `soa_hashamp`'s underlying storage array
         */
        void resize_table(unsigned int new_capacity) {
            /// Prevent unintentional downsizing of capacity to less than currently stored
            if (new_capacity < size) {
                return;
            }
            
            unsigned int prev_cap = capacity;
            /// If `new_capacity` is not a prime value, set its value to next greater prime value
            if (!is_prime(new_capacity)) {
                new_capacity = get_next_prime(new_capacity);
            }

            std::vector<hash_entry> old_heap_bucket {};
            /// Swap contents of current storage array with an empty array of same size and capacity
            old_heap_bucket.swap(hash_bucket);

            /// Reset and refill array with increased capacity
            capacity = new_capacity;
            size = 0;
            keys.clear();
            assert(keys.empty());
            for (unsigned int i = 0; i < new_capacity; i++) {
                hash_entry new_val;
                hash_bucket.insert(hash_bucket.begin() + i, new_val);
            }

            /// Rehash values according to newly increased capacity within newly reset array
            for (unsigned int j = 0; j < prev_cap; j++) {

                if (old_heap_bucket[j].is_empty != true  && old_heap_bucket[j].is_tombstone == false) {
                    add(old_heap_bucket[j].key, old_heap_bucket[j].value);
                }
            }
        }

        /**
         * If a `hash_entry` struct with matching `key` attribute already exists, replaces its originally associated
         * `value` attribute with passed value. Else, places a new `hash_entry` struct with the
         * passed `key` and associated `value` argument values at next empty position within calling `soa_hashmap`'s
         * underlying storage array `hash_bucket`
         * @param key String-type value representing the key of key : value pair to be added or modified
         * @param value `Type` value representing the value of the associated `key` to be added or modified
         */
        void add(std::string key, Hash_Type value) {
            /// Check current table load and readjust storage capacity if necessary
            double tl = table_load();
            if (tl >= 0.5) {
                resize_table(capacity * 2);
            }
            /// Generate the hash index returned by the hashing function
            unsigned int hash_func_val = apply_hash_function(key);
            unsigned int hash_index = hash_func_val % capacity;

            /// Apply quadratic probing to minimize chance of collisions
            unsigned int j = 0;
            unsigned int next_index = hash_index + (j * j);

            /// Wraparound operation if hash index exceeds current storage array bounds
            if (next_index >= capacity) {
                next_index = (hash_index + (j * j)) % capacity;
            }
            /**
             * Either:
             * 
             * Replaces the existing `value` attribute of the `hash_entry` struct holding the matching `key` attribute
             * and sets the `is_tombstone` to indicate `hash_entry`'s newly-assigned value now 'exists'
             * 
             * OR
             * 
             * Places a new `hash_entry` struct with its `key` and `value` attributes set to the argument values at the 
             * next empty index position within the `hash_bucket` array
             */
            while (hash_bucket[next_index].is_empty != true) {             
                if (hash_bucket[next_index].key.compare(key) == 0) {
                    hash_bucket[next_index].value = value;
                    // hash_bucket[next_index].is_empty = false;
                    if (hash_bucket[next_index].is_tombstone) {
                        hash_bucket[next_index].is_tombstone = false;
                        size++;
                    }
                    return;
                }
                j++;
                next_index = hash_index + (j * j);
                if(next_index >= capacity ) {
                    next_index = (hash_index + (j*j)) % capacity;
                }
            }
            hash_bucket[next_index].key = key;
            hash_bucket[next_index].value = value;
            hash_bucket[next_index].is_empty = false;
            // hash_entry new_val;
            // new_val.key = key;
            // new_val.value = value;
            // new_val.is_empty = false;
            // hash_bucket[next_index] = new_val;

            keys.push_back(key);
            size++;

        }

        /**
         * Returns associated value of `hash_entry` struct with matching `key` attribute (fails if
         * no struct holding matching `key` attribute is found)
         * @param key The `key` attribute value of `hash_entry` struct whose corresponding value attribute
         * will be returned
         * @return Value held by `hash_entry` struct with matching `key` attribute
         */
        Hash_Type get_val(std::string key) {
            /// If `soa_hashmap` has no stored values, notify user of error type before assertion
            if (size == 0) {
                gprintf("Key %s contains no values!", key.c_str());
            }              
            assert(size != 0);
            /// Generate the hash index returned by the hashing function
            unsigned int hash_func_val = apply_hash_function(key);
            unsigned int hash_index = hash_func_val % capacity;

            /// Apply quadratic probing to minimize chance of collisions
            unsigned int j = 0;
            unsigned int next_index = hash_index + (j * j);

            /// Wraparound operation if hash index exceeds current storage array bounds
            if (next_index >= capacity) {
                next_index = (hash_index + (j * j)) % capacity;
            }

            /// If search operation succeeds, index position at exit will hold matching key attribute value
            while (hash_bucket[next_index].is_empty != true) {
                if (hash_bucket[next_index].key.compare(key) == 0) {
                    if (hash_bucket[next_index].key.compare(key) == 0 && !hash_bucket[next_index].is_tombstone) {
                        break;
                    }
                }
                j++;
                next_index = hash_index + (j * j);
                if(next_index >= capacity ) {
                    next_index = (hash_index + (j*j)) % capacity;
                }
            }
            /// Notify user of error type (passed key was not found) before assertion
            if (hash_bucket[next_index].key.compare(key) != 0) {
                gprintf("Hashmap for key %s was not found!", key.c_str());
            }
            assert(hash_bucket[next_index].key.compare(key) == 0);

            return hash_bucket[next_index].value;
        }

        /**
         * Return number of index positions that do not hold a value within `hash_bucket` storage array
         * @return The total number of empty index positions within `hash_bucket` storage array
         */
        int empty_buckets() {
            int empty_bucket_count = 0;
            if (size == 0) {
                empty_bucket_count = capacity;
                return empty_bucket_count;
            }

            for (int i = 0; i < capacity; i++) {
                if (hash_bucket[i].is_empty == true) {
                    empty_bucket_count++;
                }
            }
            return empty_bucket_count;
        }

        /**
         * Determines whether a `hash_entry` struct holding the matching `key` attribute exists within the
         * calling `soa_hashmap` class object's `hash_bucket` storage array
         * @param key The value of the `hash_entry` struct's `key` attribute to searched for
         * @return `true` if a `hash_entry` holding the matching `key` attribute is found, else `false`
         */
        bool contains_key(std::string key) {
            if (size == 0) {
                return false;
            }

            unsigned int j = 0;
            unsigned int hash_func_val = apply_hash_function(key);
            unsigned int hash_index = hash_func_val % capacity;
            unsigned int next_index = hash_index + (j * j);
            if (next_index >= capacity) {
                next_index = (hash_index + (j * j)) % capacity;
            }
            
            /// Continues pobing until current position has matching key, or is empty, which indicates its absence
            while (hash_bucket[next_index].is_empty != true) {    
                if (hash_bucket[next_index].key.compare(key) == 0 && !hash_bucket[next_index].is_tombstone) {
                    return true;
                }
                j++;
                next_index = hash_index + (j * j);
                if (next_index >= capacity) {
                    next_index = (hash_index + (j * j)) % capacity;
                }
            }
            return false;
        }

        /**
         * Removes `hash_entry` struct holding matching `key` attribute value from the calling `soa_hashmap`'s
         * storage array `hash_buvket`, if found
         * @param key The value of the `hash_entry` struct's `key` attribute that to be removed
         */
        void remove( std::string key) {
            if (size == 0) {
                return;
            }
            unsigned int hash_func_val = apply_hash_function(key);
            unsigned int hash_index = hash_func_val % capacity;

            int j = 0;
            unsigned int next_index = hash_index + (j * j);
            if (next_index >= capacity) {
                next_index = (hash_index + (j * j)) % capacity;
            }
            /// is_tombstone allows for reuse of pre-allocated space and indicates if held values 'exist'
            while(hash_bucket[next_index].is_empty != true) {
                /// If matching key is found, checks bool attribute 'is_tombstone' for considered existence
                if (hash_bucket[next_index].key.compare(key) == 0 && !hash_bucket[next_index].is_tombstone) {
                    hash_bucket[next_index].is_tombstone = true;
                    size--;
                    return;
                }
                j++;
                next_index = hash_index + (j * j);
                if (next_index >= capacity) {
                    next_index = (hash_index + (j *j)) % capacity;
                }
            }
            return;
        }
        /**
         * Resets/empties all of calling `soa_hashmap` class object's stored values
         */
        void clear() {
            hash_bucket.clear();
            keys.clear();
            assert(hash_bucket.empty());
            assert(keys.empty());
            for (unsigned int i = 0; i < capacity; i++) {
                hash_entry new_val;
                hash_bucket.insert(hash_bucket.begin() + i, new_val);
            }
            size = 0;
        }

        /**
         * Overloading function for printing `soa_hashmap` class object contents to output streams
         */
        friend std::ostream& operator<<(std::ostream& out, const soa_hashmap& hmp) {
            out << "{ ";
            unsigned int key_counter = 0;
            for (unsigned int i = 0; i < hmp.capacity; i++) {
                if (hmp.hash_bucket[i].is_empty != true && !hmp.hash_bucket[i].is_tombstone) {
                    key_counter++;
                    
                    out << hmp.hash_bucket[i].key << " : " << hmp.hash_bucket[i].value;
                    if ( key_counter != hmp.size) {
                        out << ", ";
                    }
                }
            }
            out << " }";
            return out;
        }
            
    private:
        /// @brief Current number of existing `hash_entry` structs stored in `hash_bucket` array
        unsigned int size;
        /// @brief Total number of index positions accessible within `hash_bucket` array (0 to capacity-1)
        unsigned int capacity;
        /// @brief Struct holing key : value pairs and boolean indicators (for removal/search operations)
        struct hash_entry {
            /// @brief Key value of key : value pair
            std::string key;
            /// @brief Corresponding value of key : value pair
            Hash_Type value;
            /// @brief Boolean indicator of whether a `hash_entry` struct with a pre-assigned value 'exists'
            bool is_tombstone = false;
            /// @brief Boolean indicator for detecting `hash_entry` structs with no pre-assigned attribute values
            bool is_empty = true;
        };
        /// @brief Underlying storage array of `soa_hashmap` class object
        std::vector<hash_entry> hash_bucket{};
        /// @brief Array containing all currently existing keys stored in `soa_hashmap` class object
        std::vector<std::string> keys {};
};

/**
 * Customized multi-map class objects that utilize open-addressing and an underlying
 * vector-type storage array `main_hash_bucket` that store `soa_hashmap` class objects
 * @tparam Type typename of values for both `main_hashmap` and any `soa_hashmap` class objects
 * to store as the values of all key : `Type` value pairs held by both class objects
 * @warning Declared `Type` of `main_hashmap` and any `soa_hashmap` objects it is storing must be the same
 * 
 * For example:
 * 
 * `main_hashmap<double>` can only contain `soa_hashmap<double>` class objects with key : `double` value pairs
 * 
 * `main_hashmap<std::string>` can only contain `soa_hashmap<std::string>` class objects with key : `std::string` value pairs
 *  
 */
template<class Type>
class main_hashmap {
    public:
        /// Constructor builds underlying storage array with a starting bucket capacity of `c`
        main_hashmap(unsigned int c): main_size(0), main_capacity(c) {fill_buckets();}
        /// Constructor defaults to capacity of 5 if no capacity argument is provided
        main_hashmap(): main_size(0), main_capacity(5) {fill_buckets();}

        /**
         * Pre-fills `main_hashmap`'s underlying vector-type storage array, `main_hash_bucket` with `capacity`
         * number of empty `hash_table` structs to store individual `soa_hashmap` objects
         * 
         * Upon initialization of `main_hashmap`, all indices between 0 and `capacity` can be dynamically accessed
        */
        void fill_buckets() {
            for (unsigned int i = 0; i < main_capacity; i++) {
                hash_table new_val;
                main_hash_bucket.insert(main_hash_bucket.begin() + i, new_val);
            }
        }

        /**
         * Retrieves current number of `hash_table` structs stored within `master_hash_bucket` storage array
         * of calling `main_hashmap` class object
         * @return Number of non-empty elements currently stored in calling `main_hashmap` class object
         */
        unsigned int get_size() {
            return main_size;
        }

        /**
         * Retrieves total number of indices (0 to capacity - 1) that can be dynamically accessed from 
         * `master_hash_bucket` array
         * (Underlying array contains preallocated space for both empty and non-empty elements between this range)
         * @return Maximum number of indices currently available for value storage (indices 0 to capacity - 1)
         */        
        unsigned int get_capacity() {
            return main_capacity;
        }

        /**
         * Calculates and returns the current load factor of calling `main_hashmap` class object
         * @note Load Factor = Current number of non-empty `hash_table` structs divided by current array capacity
         * @return Value of current calculated load factor of colling `main_hashmap` class object
         */
        double table_load() {
            double load_factor = static_cast<double>(main_size) / static_cast<double>(main_capacity);
            return load_factor;
        }

        /**
         * Modifies the capacity of calling `main_hashmap` object's underlying storage array `main_hash_bucket` to
         * either the value of `new_capacity`, if it is a prime value, or the next prime value greater
         * than `new_capacity`
         * @param new_capacity Value to be used in readjusting the capacity of `main_hashamp`'s underlying storage array
         */
        void resize_table(unsigned int new_capacity) {
            /// Prevent unintentional downsizing of capacity to less than currently stored
            if (new_capacity < main_size) {
                return;
            }
            /// If `new_capacity` is not a prime value, set its value to next greater prime value           
            unsigned int prev_cap = main_capacity;
            if (!is_prime(new_capacity)) {
                new_capacity = get_next_prime(new_capacity);
            }

            /// Swap contents of current storage array with an empty array of same size and capacity
            std::vector<hash_table> old_heap_bucket {};
            old_heap_bucket.swap(main_hash_bucket);

            /// Reset and refill array with increased capacity
            main_capacity = new_capacity;
            main_size = 0;
            main_keys.clear();
            assert(main_keys.empty());


            for (unsigned int i = 0; i < new_capacity; i++) {
                hash_table new_val;
                main_hash_bucket.insert(main_hash_bucket.begin() + i, new_val);
            }
            /// Rehash values according to newly increased capacity within newly reset array
            for (unsigned int j = 0; j < prev_cap; j++) {

                if (old_heap_bucket[j].is_empty != true  && old_heap_bucket[j].is_tombstone == false) {
                    add_key(old_heap_bucket[j].main_key, old_heap_bucket[j].entry);
                }
            }
        }

        /**
         * Retrieves current array of key values stored within `main_keys` member of calling `main_hashmap` class object
         * @return vector-type array holding all unique keys currently stored within calling `main_hashmap` class object
         */
        std::vector<std::string> get_main_keys() {
            return main_keys;
        }

        /**
         * Retrieves the underlying storage array of the calling `main_hashmap` class object
         * @return vector-type array of `hash_table` structs holding all `soa_hashmap` class objects
         * in calling `main_hashmap` class object
         */
        auto get_main_hash_bucket() {
            return main_hash_bucket;
        }

        /**
         * Prints all string key values found within calling `main_hashmap` object to output streams
         */
        void print_main_keys() {
            std::cout << "[ ";
            for (unsigned int i = 0; i < main_keys.size(); i++) {
                
                if ( i == main_keys.size() - 1) {
                    std::cout << main_keys[i];
                } else {
                    std::cout << main_keys[i] << ", ";
                }
            }
            std::cout << " ]";
        }


        /**
         * If a `hash_table` struct with matching `key` attribute already exists within the calling `main_hashmap` class object,
         * replaces the `soa_hashmap` class object (and its contents) orginally associated with the `entry` attribute of the `soa_hashmap` object
         *  with the `soa_hashmap` object referenced by the `hash_list` value.
         * 
         * Else, places a new `hash_table` struct with its `key` attribute assigned to the passed `key` and its `entry` attribute assigned to
         * the `soa_hashmap` object at the next empty index position within calling `main_hashmap`'s underlying storage array `main_hash_bucket`
         * 
         * @param key String-type value representing the key attribute of `hash_table` struct to be added or modified
         * @param hash_list The `soa_hashmap` class object to be added or modified within the `hash_table` struct with the matching `key`
         */
        void add_key(std::string key, soa_hashmap<Type>& hash_list) {
            /// Check current table load and readjust storage capacity if necessary
            double tl = table_load();
            if (tl >= 0.5) {
                resize_table(main_capacity * 2);
            }

            /// Generate the hash index returned by the hashing function
            unsigned int hash_func_val = apply_hash_function(key);
            unsigned int hash_index = hash_func_val % main_capacity;

            /// Apply quadratic probing to minimize chance of collisions
            unsigned int j = 0;
            unsigned int next_index = hash_index + (j * j);

            if (next_index >= main_capacity) {
                next_index = (hash_index + (j * j)) % main_capacity;
            }
            /**
             * Either:
             * 
             * Replaces the existing `entry` attribute of the `hash_table` struct holding the matching `key` attribute
             * 
             * OR
             * 
             * Places a new `hash_entry` struct with its `key` and `value` attributes set to the argument values at the 
             * next empty index position within the `hash_bucket` array
             */
            while (main_hash_bucket[next_index].is_empty != true) {
                
                if (main_hash_bucket[next_index].main_key.compare(key) == 0) {
                    
                    main_hash_bucket[next_index].entry = hash_list;
                    // main_hash_bucket[next_index].is_empty = false;
                    if (main_hash_bucket[next_index].is_tombstone) {
                        main_hash_bucket[next_index].is_tombstone = false;
                        main_size++;
                    }
                    return;
                }
                j++;
                next_index = hash_index + (j * j);
                if(next_index >= main_capacity ) {
                    next_index = (hash_index + (j*j)) % main_capacity;
                }
            }
            // std::cout << "Adding " << key << "with value " << value << "to index " << next_index << '\n';
            hash_table new_val;
            new_val.main_key = key;
            
            new_val.entry = hash_list;
            new_val.is_empty = false;
            
            main_hash_bucket[next_index] = new_val;
            main_keys.push_back(key);
            main_size++;
        }

        soa_hashmap<Type>& get_key_list(std::string key) {
            
            
            if (main_size == 0) {
                gprintf("Main Hashmap %s is empty!", key.c_str());
                // std::cerr << "Hashmap for key " << key << " is empty!" << '\n';
                // return main_hash_bucket[0].entry;
            }
            assert(main_size != 0);

            unsigned int hash_func_val = apply_hash_function(key);
            unsigned int hash_index = hash_func_val % main_capacity;

            unsigned int j = 0;
            unsigned int next_index = hash_index + (j * j);
            if (next_index >= main_capacity) {
                next_index = (hash_index + (j * j)) % main_capacity;
            }
            while (main_hash_bucket[next_index].is_empty != true) {
                hash_table target_val = main_hash_bucket[next_index];
                if (main_hash_bucket[next_index].main_key.compare(key) == 0) {
                    break;
                    // return main_hash_bucket[next_index].entry;
                }
                j++;
                next_index = hash_index + (j * j);
                if(next_index >= main_capacity ) {
                    next_index = (hash_index + (j*j)) % main_capacity;
                }
            }
            if (main_hash_bucket[next_index].main_key.compare(key) != 0) {
                gprintf("Main Hashmap does not contain a hashmap for %s!", key.c_str());
            }
            assert(main_hash_bucket[next_index].main_key.compare(key) == 0);
            // std::cerr << "Hashmap for key " << key << " was not found!" << '\n';
            return main_hash_bucket[next_index].entry;
        }

        Type get_key_val(std::string main_key, std::string target_key) {
            if (main_size == 0) {
                gprintf("The Main Hashmap %s is empty!", main_key.c_str());
                // std::cerr << "The hashmap " <<  main_key << " is empty!" << '\n';
                // return main_hash_bucket[0].entry.get_val(target_key); 
            }

            assert(main_size != 0);
            
            unsigned int hash_func_val = apply_hash_function(main_key);
            unsigned int hash_index = hash_func_val % main_capacity;

            unsigned int j = 0;
            unsigned int next_index = hash_index + (j * j);
            if (next_index >= main_capacity) {
                next_index = (hash_index + (j * j)) % main_capacity;
            }
            while (main_hash_bucket[next_index].is_empty != true) {
                hash_table target_val = main_hash_bucket[next_index];
                if (main_hash_bucket[next_index].main_key.compare(main_key) == 0) {
                    // soa_hashmap target_val = main_hash_bucket[next_index].entry;
                    // std::cout << target_val << '\n';
                    break;
                    // return main_hash_bucket[next_index].entry.get_val(target_key);
                }
                j++;
                next_index = hash_index + (j * j);
                if(next_index >= main_capacity ) {
                    next_index = (hash_index + (j*j)) % main_capacity;
                }
            }
            if (main_hash_bucket[next_index].main_key.compare(main_key) != 0) {
                gprintf("The key %s does not exist in %s", target_key.c_str(), main_key.c_str());
            }
            assert(main_hash_bucket[next_index].main_key.compare(main_key) == 0);
            // gprintf("The key %s does not exist in %s", target_key.c_str(), main_key.c_str());
            // std::cerr << "The key " << target_key << " does not exist in " <<  main_key << '\n';
            return main_hash_bucket[next_index].entry.get_val(main_key);
        }
        

        std::string get_key_by_val(std::string main_key, Type value) {
            // std::string failure = "";
            if (main_size == 0) {
                gprintf(" Main Hashmap %s is empty!", main_key.c_str());                
                // return failure;
            }

            assert(main_size != 0);

            unsigned int hash_func_val = apply_hash_function(main_key);
            unsigned int hash_index = hash_func_val % main_capacity;

            unsigned int j = 0;
            unsigned int next_index = hash_index + (j * j);
            if (next_index >= main_capacity) {
                next_index = (hash_index + (j * j)) % main_capacity;
            }
            unsigned int l = 0;
            auto entry_hash = main_hash_bucket[next_index].entry.get_hash_bucket();
            while (main_hash_bucket[next_index].is_empty != true) {
                // hash_table target_val = main_hash_bucket[next_index];
                if (main_hash_bucket[next_index].main_key.compare(main_key) == 0) {
                    // soa_hashmap target_val = main_hash_bucket[next_index].entry;
                    // std::cout << target_val << '\n';
                    entry_hash = main_hash_bucket[next_index].entry.get_hash_bucket();
                    // auto entry_hash = main_hash_bucket[next_index].entry.get_hash_bucket();
                    unsigned int entry_capacity = static_cast<unsigned int>(main_hash_bucket[next_index].entry.get_capacity());
                    
                    for (unsigned int k = 0; k <  entry_capacity; k++) {
                        if (entry_hash[k].is_empty != true && !entry_hash[k].is_tombstone) {
                            if (entry_hash[k].value == value) {
                                l = k;
                                break;
                                // return entry_hash[k].key;
                            }
                        }
                    }

                }
                j++;
                next_index = hash_index + (j * j);
                if(next_index >= main_capacity ) {
                    next_index = (hash_index + (j*j)) % main_capacity;
                }
            }
            if (entry_hash[l].value != value) {
                gprintf("Main Hashmap does not contain any keys of %s with argument value!", main_key.c_str());
            }
            assert(entry_hash[l].value == value);
            // gprintf("Hashmap for key %s was not found!", main_key.c_str());
            
            return entry_hash[l].key;
        }
    
        

        int empty_buckets() {
            int empty_bucket_count = 0;
            if (main_size == 0) {
                empty_bucket_count = main_capacity;
                return empty_bucket_count;
            }

            for (int i = 0; i < main_capacity; i++) {
                if (main_hash_bucket[i].is_empty == true) {
                    empty_bucket_count++;
                }
            }
            return empty_bucket_count;
        }

        bool contains_key(std::string key) {
            if (main_size == 0) {
                return false;
            }

            unsigned int j = 0;
            unsigned int hash_func_val = apply_hash_function(key);
            unsigned int hash_index = hash_func_val % main_capacity;
            unsigned int next_index = hash_index + (j * j);
            if (next_index >= main_capacity) {
                next_index = (hash_index + (j * j)) % main_capacity;
            }
            
            while (main_hash_bucket[next_index].is_empty != true) {
                
                if (main_hash_bucket[next_index].main_key.compare(key) == 0 && !main_hash_bucket[next_index].is_tombstone) {
                    return true;
                }
                j++;
                next_index = hash_index + (j * j);
                if (next_index >= main_capacity) {
                    next_index = (hash_index + (j * j)) % main_capacity;
                }
            }
            return false;
        }

        void remove( std::string key) {
            if (main_size == 0) {
                return;
            }
            unsigned int hash_func_val = apply_hash_function(key);
            unsigned int hash_index = hash_func_val % main_capacity;

            int j = 0;
            unsigned int next_index = hash_index + (j * j);
            if (next_index >= main_capacity) {
                next_index = (hash_index + (j * j)) % main_capacity;
            }
            
            while(main_hash_bucket[next_index].is_empty != true) {
                
                if (main_hash_bucket[next_index].main_key.compare(key) == 0 && !main_hash_bucket[next_index].is_tombstone) {
                    main_hash_bucket[next_index].is_tombstone = true;
                    main_size--;
                    return;
                }
                j++;
                next_index = hash_index + (j * j);
                if (next_index >= main_capacity) {
                    next_index = (hash_index + (j *j)) % main_capacity;
                }
            }
            return;
        }

        void clear() {
            main_keys.clear();
            main_hash_bucket.clear();
            assert(main_hash_bucket.empty());
            assert(main_keys.empty());
            for (unsigned int i = 0; i < main_capacity; i++) {
                hash_table new_val;
                main_hash_bucket.insert(main_hash_bucket.begin() + i, new_val);
            }
            main_size = 0;
        }

        friend std::ostream& operator<<(std::ostream& out, const main_hashmap<Type>& hmp) {
            out << "{ ";
            unsigned int key_counter = 0;
            for (unsigned int i = 0; i < hmp.main_capacity; i++) {
                
                if (hmp.main_hash_bucket[i].is_empty != true && !hmp.main_hash_bucket[i].is_tombstone) {
                    key_counter++;
                    out << hmp.main_hash_bucket[i].main_key << " : " << hmp.main_hash_bucket[i].entry;
                    if ( key_counter != hmp.main_size) {
                        out << ", ";
                    }
                }
            }
            out << " }";
            return out;
        }

    private:
        
        unsigned int main_size;
        unsigned int main_capacity;
        struct hash_table {
            std::string main_key;
            soa_hashmap<Type> entry = soa_hashmap<Type>();
            
            bool is_tombstone = false;
            bool is_empty = true;
        };
        std::vector<std::string> main_keys {};
        std::vector<hash_table> main_hash_bucket{};
        
};

extern void prefill_hash_keys(main_hashmap<std::string>& main_hash, std::vector<std::string>& key_list, unsigned int vertex_count);